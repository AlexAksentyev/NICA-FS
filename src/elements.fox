
INCLUDE '~/REPOS/COSYINF-CORE/bin/utilities';

PROCEDURE ROTATE PHI;
  VARIABLE M NM1 4; VARIABLE ANG NM2;
  VARIABLE i 1;
  ANG := PHI*DEGRAD;
  M(1):= COS(ANG)*MAP(1) + SIN(ANG)*MAP(3);
  M(3):=-SIN(ANG)*MAP(1) + COS(ANG)*MAP(3);
  M(2):= COS(ANG)*MAP(2) + SIN(ANG)*MAP(4);
  M(4):=-SIN(ANG)*MAP(2) + COS(ANG)*MAP(4);
  LOOP i 1 4; MAP(i):=M(i);  ENDLOOP;
  RSA PHI;
ENDPROCEDURE; {ROTATE}

FUNCTION BMULT KNL L; {COMPUTES MAGNETIC INDUCTION FOR A MADX MULTIPOLE ELEMENT}
  BMULT := KNL/L * CONS(CHIM);
ENDFUNCTION; {BMULT}

PROCEDURE THINMQ L {m} TILT {rad} K1 {m^-2};
                 {see QUAD for parameter explanations}
  VARIABLE OM NM1;
  WRITE 6 '***** THIN QUADRUPOLE DEFINITION';
  OM := SQRT(ABS(K1));
  UMS;
  {load thin quad orbital map into MSC}
  IF CONS(K1)>0;
    MSC(2) := -OM*SIN(OM*L)*DD(1) + 1*DD(2);
    MSC(4) := OM*SINH(OM*L)*DD(3) + 1*DD(4);
  ELSEIF CONS(K1)<0;
    MSC(2) := OM*SINH(OM*L)*DD(1) + 1*DD(2);
    MSC(4) := -OM*SIN(OM*L)*DD(3) + 1*DD(4);
  ELSEIF TRUE;
    DL L;
  ENDIF;
  {load thin quad spin map into SSCR}
  {*** NOT IMPLEMENTED yet, SSCR = Identity ***}
  {apply MSC and SSCR to MAP, SPNR respectively.}
  LOCSET 0 0 0 0 0 0; UPDATE 1 1;
ENDPROCEDURE;

PROCEDURE QUAD1 L {m} TILT G; {BNL-type quadrupole definition}
  VARIABLE L0 1;
  VARIABLE G0 1;
  VARIABLE TILT0 1;
  WRITE 6 'BNL TYPE QUAD IN NICA FS';

  L0:=L;{in meters}
  IF (G=0); WRITE 6 'G=0';
    DL L0;
  ELSEIF (1=1); 
    G0:=G*10;{in Tesla/m}
    TILT0:=TILT;
    ROTATE TILT0;
    WRITE 6 'B = '&ST(G0*.05);
    MQ L0 G0*0.05 0.05; {Magnetic quadrupole}
    {WRITE 6 'MQ' L0 G0*0.05;}
    ROTATE -TILT0;
  ENDIF;
ENDPROCEDURE; { END OF QUADRUPOLE }


PROCEDURE QUAD L {m} TILT {rad} K1 {m^-2} ;
  {L quadrupole length}
  {K1 = B_Y/X / (B_0 R) [m^-2]}
      {COSY wants magnetic induction at the pole,}
      {which is B_y(a) = B*\rho*K_1*a, a = aperture}
      {checked with Optim; there K1 is Tl/m (not normalized by B\rho)}
      {hence B_y(a) = K1 * a in the automatic converter}
  VARIABLE Bpt 1; {magnetic induction (flux density @ pole tip)}
  VARIABLE A 1; {aperture}
  WRITE 6 'NICA FS QUAD DEFINITION';
  A:=.05;
  {this is the native COSY Infinity THICK LENS option}
  Bpt := K1*CONS(CHIM)*A; {in Tesla}
  WRITE 6 'B = '&ST(Bpt);
  MQ L Bpt A;
  { THINMQ L 0 K1; } {using the THIN LENS matrix}
ENDPROCEDURE; {QUAD}

PROCEDURE SEXT L {m} TILT {rad} KNL {unit};
  VARIABLE Bpt 1;
  VARIABLE L0 1;
  Bpt := BMULT(KNL, L);
  IF Bpt=0; DL L;
  ELSEIF TRUE; MH L Bpt .05;
  ENDIF;
ENDPROCEDURE; {SEXT}

PROCEDURE OCT L {m} TILT {rad} KNL {unit};
  VARIABLE Bpt 1;
  Bpt := BMULT(KNL, L);
  MO L Bpt .05;
ENDPROCEDURE; {OCT}

PROCEDURE MULT TILT {rad} KNL {unit} N;
  VARIABLE Bpt 1 N; VARIABLE I 1;
  VARIABLE L0 1; VARIABLE FLAG 1; {used to check magnetic field components against 0}
  L0 := .1;
  LOOP I 1 N;
    Bpt(I) := BMULT(KNL(I), L0);
    IF Bpt(I)#0; FLAG:=1; ENDIF;
  ENDLOOP;
  IF FLAG#0; MM L0 Bpt N .05;
  ELSEIF TRUE; DL L0; WRITE 6 'MULTIPOLE IS OFF';
  ENDIF;
ENDPROCEDURE;

PROCEDURE SBEND L {m} ANGLE {rad} TILT {rad} E1 {rad} H1 {1/m} E2 {rad} H2{1/m} FINT {unit} FINTX {unit};
  VARIABLE R 1; VARIABLE ANGLE0 1; VARIABLE TILT0 1;
  VARIABLE E10 1; VARIABLE E20 1;
  E10 := E1/DEGRAD;
  E20 := E2/DEGRAD;
  ANGLE0 := ABS(ANGLE)/DEGRAD;
  TILT0 := TILT/DEGRAD;
  R := L/ANGLE0;
  IF ANGLE<0; CB; ENDIF;
  ROTATE TILT0;
    DI R ANGLE0 .1 E1 H1 E2 H2;
  ROTATE -TILT0;
  IF ANGLE<0; CB; ENDIF;
ENDPROCEDURE; {SBEND}

PROCEDURE RBEND L {m} ANGLE {rad} TILT {rad};
  VARIABLE R 1; VARIABLE ANGLE0 1; VARIABLE TILT0 1;
  WRITE 6 'IN RBEND';
  WRITE 6 'ANGLE = '&ST(ANGLE);
  ANGLE0 := ABS(ANGLE)/DEGRAD;
  WRITE 6 'DEGRAD = '&ST(DEGRAD)
           'ANGLE0 = '&ST(ANGLE0)
           'ANGLE = '&ST(ANGLE);
  TILT0 := TILT*DEGRAD;
  R := L/ANGLE;
  WRITE 6 'R ='&ST(R);
  IF ANGLE<0; CB; WRITE 6 'CB'; ENDIF;
  ROTATE TILT0;
    DP R ANGLE0 .1;
  ROTATE -TILT0;
  IF ANGLE<0; CB; ENDIF;
ENDPROCEDURE; {RBEND}

PROCEDURE SOLENOID L {m} KS {rad/m};
  VARIABLE B0 1; VARIABLE A 1;
  A := .05;
  B0 := KS * CONS(CHIM);
  IF (B0 = 0); DL L; WRITE 6 'SOLENOID IS OFF';
  ELSEIF TRUE;
    CMS B0 A L;
  ENDIF;
ENDPROCEDURE; {SOLENOID}

PROCEDURE RFCAV L {m} VOLT {MV} LAG {rad} HARMON {unit};
  IF VOLT=0;
    DL L;
  ELSEIF TRUE;
    WRITE 6 'UNIMPLEMENTED ERROR!';
  ENDIF;
ENDPROCEDURE;

PROCEDURE KICK L {m} KX {unit} KY {unit};
  IF ((KX=0) * (KY=0));
    DL L;
  ELSEIF TRUE;
    WRITE 6 'UNIMPLEMENTED ERROR!';
  ENDIF;
ENDPROCEDURE;

{I PUT THIS ELEMENT HERE TO CHECK AGAINST THE BNL LATTICE}
PROCEDURE WIEN L2 B1 B2 TILT; {homogenous WF; closed orbit preserved}
{parasitic (tilt) fields are implemented via a spin kick like Eremey thesis section 6.5.3}
  VARIABLE R1 1;
  VARIABLE R2 1;
  VARIABLE B0 1; VARIABLE B3 1;
  VARIABLE L1 1;
  VARIABLE TILT0 1; VARIABLE TOF 1;
  VARIABLE BX 1; VARIABLE EY 1;
  VARIABLE BETA 1; VARIABLE DWMDM 1; 
  L1:=L2/100; {in meters}
  B0:=ABS(B1)/10; {in Tesla}
  B3:=ABS(B2)*1e5;   {in V/m}
  R2:=CONS(CHIM)/B0;
  R1:=CONS(CHIE)/B3;
  TILT0 := TILT;
  WF R1 R2 L1 0.05;
  IF TILT0#0;
    BX := B0*TAN(TILT0);
    EY := CONS(CHIE)/CONS(CHIM)*BX;
    BETA := CONS(V0)/CLIGHT;
    DWMDM := Z0/M0*EZERO/AMU*(G0*BX - (G0 - 1/BETA/BETA + 1)*BETA*EY/CLIGHT);
    TOF := L1/CONS(V0);
    RSX TOF*DWMDM;
  ENDIF;    
ENDPROCEDURE; { END OF WIEN }


 
SAVE 'bin/elements';
