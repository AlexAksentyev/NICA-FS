INCLUDE 'bin/core/cosy';

{ ## ******************** ORGANIZATIONAL TOOLS ******************** ## }

PROCEDURE DIRSET VAR PATH;
  VAR := PATH;
  OS 'mkdir -p '&PATH; WRITE 6 'WRITING TO: '&PATH;
  OS 'rm -vf '&PATH&'*';
ENDPROCEDURE;

FUNCTION FILENAME WHERE NAME MARKER;
  VARIABLE SEP 1;
  SEP := ':'; IF MARKER=''; SEP:=''; ENDIF;
  FILENAME := WHERE&NAME&SEP&MARKER&'.dat';
ENDFUNCTION;

FUNCTION MRK I; MRK := LTRIM(SF(I, '(I10)')); ENDFUNCTION;

FUNCTION FORM VEC;
  VARIABLE FMT 10; VARIABLE I 1;
  FMT := '(E40.29)'; FORM:='';
  LOOP I 1 LENGTH(VEC);
    FORM := FORM&SF(VEC|I, FMT);
  ENDLOOP;
ENDFUNCTION;

PROCEDURE WRITETBL OU ARR NARR MARKER; {writes ar array of vectors in table (matrix) form}
  VARIABLE NVEC 1; VARIABLE I 1; VARIABLE J 1;
  VARIABLE ROW 101;
  NVEC := LENGTH(ARR(1));
  LOOP I 1 NVEC;
    ROW := ARR(1)|I;
    LOOP J 2 NARR; ROW := ROW&(ARR(J)|I); ENDLOOP;
    WRITE OU MARKER&' '&MRK(I-1)&' '&FORM(ROW);
  ENDLOOP;
ENDPROCEDURE;



{ ## ******************** PROCEDURES ACTIVELY USED IN SCRIPTS  ******************** ## }
FUNCTION ZEROS NUM; {CREATES A VECTOR OF ZEROS}
  VARIABLE I 1; VARIABLE RES NUM;
  RES := 0;
  LOOP I 2 NUM; RES := RES&0; ENDLOOP;
  ZEROS:=RES;
ENDFUNCTION;

FUNCTION ONES NUM; {CREATES A VECTOR OF ONES}
  VARIABLE I 1; VARIABLE RES NUM;
  RES := 1;
  LOOP I 2 NUM; RES := RES&1; ENDLOOP;
  ONES:=RES;
ENDFUNCTION;

FUNCTION LINSPACE LOW HIGH NUM;
  VARIABLE I 1; VARIABLE DELTA 1; VARIABLE RES NUM;
  DELTA := (HIGH-LOW)/(NUM-1);
  RES := LOW;
  LOOP I 2 NUM; RES := RES&(LOW + DELTA*(I-1));  ENDLOOP;
  LINSPACE := RES;
ENDFUNCTION;

FUNCTION VEGAUSS MEAN SIGMA NUM PATH; {generate a vector of normally distributed random numbers}
  {PATH --- path to the data file containing the sequence of random numbers}
  VARIABLE VAL 1;
  OS 'analysis/gauss.py '&ST(MEAN)&' '&ST(SIGMA)&SF(NUM,'(I10)')&' '&PATH&'.in';
  OPENF 100500 PATH&'.in' 'OLD'; READ 100500 VAL;
  WHILE ST(VAL)#'';
    VEGAUSS:=VEGAUSS&VAL;
    READ 100500 VAL;
  ENDWHILE;
  CLOSEF 100500;
  VEGAUSS := VEGAUSS|(2&LENGTH(VEGAUSS));
ENDFUNCTION;

PROCEDURE GET_TUNE_ENSEMBLE MUARR; {COMPUTES THE ENSEMBLE OF SPIN TUNES FOR GIVEN RAYS, LATTICE}
  VARIABLE K 1; VARIABLE MU 5000; VARIABLE NBAR 5000 3;
  TSS MU NBAR 0;
  MUARR(1) := MU; LOOP K 1 3; MUARR(K+1) := NBAR(K); ENDLOOP;
  POLVAL 1 MUARR 4 RAY TWOND MUARR 4;
ENDPROCEDURE; {GET_TUNE_ENSEMBLE}

FUNCTION REVFREQ Lcir; { Computes the particle REVOLUTION FREQUENCY; 
                          to be called AFTER RP }
  REVFREQ := CONS(V0)/Lcir;
ENDFUNCTION;

FUNCTION STD VEC;
  VARIABLE MEAN 1; VARIABLE N 1;
  MEAN := RE(VEC); N := LENGTH(VEC) - 1; {if 1 is not removed, the std estimator is biased}
  STD := SQRT(ABS(SQR(VEC-MEAN))/N);
ENDFUNCTION;

{ ## ******************** PLOTTING TOOLS ******************** ## }
PROCEDURE GET_BOUNDS X Y XMIN XMAX YMIN YMAX DX DY;
  VARIABLE N 1;
  N := LENGTH(X);
  XMIN := VMIN(X); XMAX := VMAX(X);
  YMIN := VMIN(Y); YMAX := VMAX(Y);
  DX := (XMAX-XMIN)/(NRAY-2);
  DY := (YMAX-YMIN)/(NRAY-2);
ENDPROCEDURE; {GET_BOUNDS}

PROCEDURE FRAME_SETUP X Y PLOT TITLE;
  VARIABLE FMT 10;
  VARIABLE XMIN 1; VARIABLE XMAX 1;
  VARIABLE YMIN 1; VARIABLE YMAX 1;
  VARIABLE DX 1; VARIABLE DY 1;
  FMT := '(E9.3)';
  GET_BOUNDS X Y XMIN XMAX YMIN YMAX DX DY;
  FG PLOT XMIN XMAX YMIN YMAX DX DY TITLE 0;
  GRMOVE (XMIN-1.2*DX) YMIN 0 PLOT; GRCHAR SF(XMIN, FMT) PLOT;
  GRMOVE XMIN (YMIN-DY*.5)  0 PLOT; GRCHAR SF(YMIN, FMT) PLOT;
  GRMOVE (XMAX-DX) YMIN 0 PLOT; GRCHAR SF(XMAX, FMT) PLOT;
  GRMOVE XMAX YMAX  0 PLOT; GRCHAR SF(YMAX, FMT) PLOT;
ENDPROCEDURE; {FRAME SETUP}

PROCEDURE DRAW_LAYER XVEC YVEC PLOT;
  VARIABLE N 1; VARIABLE X 1 1000; VARIABLE Y 1 1000;
  VARIABLE I 1;
  N := LENGTH(XVEC);
  LOOP I 1 N;
    X(I) := XVEC|I;
    Y(I) := YVEC|I;
  ENDLOOP;
  CG PLOT X Y N;
ENDPROCEDURE; {DRAW_LAYER}

{ ## *************** FORMAL METHODS *************** ## }
PROCEDURE SANM N M O;
  {this is the equivalent of ANM for 3 x 3 matrices (SPNR)}
  {computes the MATRIX PRODUCT}
  VARIABLE I 1; VARIABLE J 1;
  LOOP I 1 3;
    LOOP J 1 3;
      O(I,J) := N(I,1)*M(1,J) + N(I,2)*M(2,J) + N(I,3)*M(3,J);
    ENDLOOP;
  ENDLOOP;
ENDPROCEDURE;

PROCEDURE S3NM N M;
  VARIABLE I 1; VARIABLE J 1;
  LOOP I 1 3; LOOP J 1 3; M(I,J) := N(I,J); ENDLOOP; ENDLOOP;
ENDPROCEDURE;

FUNCTION VEREV VEC; {reverses vector element order}
  VARIABLE N 1; VARIABLE NMID 1;
  VARIABLE I 1; VARIABLE DUM 1;
  VARIABLE RES LENGTH(VEC); 
  N := LENGTH(VEC); RES := VEC;
  IF MOD(N, 2)=0; NMID := N/2;
  ELSEIF LO(1); NMID := INT(N/2); ENDIF;
  LOOP I 1 NMID;
    VELGET RES (N-I+1) DUM;
    VELSET RES (N-I+1) RES|I;
    VELSET RES I DUM;
  ENDLOOP;
  VEREV := RES;
ENDFUNCTION;

{ ################# CANDIDATES FOR REMOVAL #################}
PROCEDURE SMAPS POS MAPARR SPNRARR; {SAVE SEGMENT TRANSFER MAPS TO ARRAY ELEMENT}
  VARIABLE I 1; VARIABLE J 1;
  LOOP I 1 TWOND; MAPARR(I, POS) := MAP(I);ENDLOOP;
  LOOP I 1 3;
    LOOP J 1 3; SPNRARR(I,J,POS) := SPNR(I,J); ENDLOOP;
  ENDLOOP;
ENDPROCEDURE;
PROCEDURE RMAPS POS MAPARR SPNRARR; {READ SEGMENT TRANSFER MAPS FROM ARRAY}
  VARIABLE I 1; VARIABLE J 1;
  UM;
  LOOP I 1 TWOND; MAP(I) := MAPARR(I, POS); ENDLOOP;
  LOOP I 1 3;
    LOOP J 1 3; SPNR(I,J) := SPNRARR(I,J,POS); ENDLOOP;
  ENDLOOP;
ENDPROCEDURE;

PROCEDURE TREL MAPARR SPNRARR NEL NTRN PRAYOU PSPIOU;
  {Element-by-element tracking}
  VARIABLE TRN 1; VARIABLE EL 1;
  VARIABLE NR 1; VARIABLE NS 1;
  VARIABLE DUM 1; VARIABLE I 1;
  PROCEDURE WTRPRAY IT ELN;
    VARIABLE STR 500;
    VARIABLE J 1; VARIABLE I 1;
    IF IT=0 ; NR := LENGTH(RAY(1)); IF NR=1; NR:=0; ENDIF;
      WRITE PRAYOU '# number of rays:'&SF(NR,'(I8)') ;
      IF NR>0 ; STR := '# iteration   EID   ray    X              A' ;
         IF TWOND>2 ; STR := STR&'              Y              B' ;
            ENDIF ;
         IF TWOND>4 ; STR := STR&'              T              D' ;
            ENDIF ;
         IF TWOND>6 ; STR := STR&'              G              Z' ;
            ENDIF ;
         WRITE PRAYOU STR ;
      ENDIF ;
    ELSEIF TRUE ; WRITE PRAYOU '' ; ENDIF ;
    LOOP J 1 NR ; STR := SF(IT,'(I10)')&SF(ELN,'(I6)')&' '&SF(J-1,'(I6)') ;
      LOOP I 1 TWOND ; STR := STR&SF((RAY(I)|J),'(E15.7)') ; ENDLOOP ;
      WRITE PRAYOU STR ;
    ENDLOOP ;
  ENDPROCEDURE; {WTRPRAY}
  PROCEDURE WTRPSPI IT ELN;
    VARIABLE STR 500;
    VARIABLE I 1; VARIABLE J 1;
    IF IT=0 ; NS := LENGTH(SPI(1)) ; IF NS=1 ; NS := 0 ; ENDIF ;
      WRITE PSPIOU '# number of spin vectors:'&SF(NS,'(I8)') ;
      IF NS>0 ; WRITE PSPIOU ('# iteration   EID vector   S_X'&
                      '            S_Y            S_Z') ; ENDIF ;
    ELSEIF TRUE ; WRITE PSPIOU '' ; ENDIF ;
    LOOP J 1 NS ; STR := SF(IT,'(I10)')&SF(ELN, '(I6)')&' '&SF(J-1,'(I6)') ;
      LOOP I 1 3 ; STR := STR&SF((SPI(I)|J),'(E15.7)') ; ENDLOOP ;
      WRITE PSPIOU STR ;
    ENDLOOP ;
  ENDPROCEDURE; {WTRPSPI}
  CR;
  {the following three rays mimic the reference particle}
  SR 1e-9 0 0 0 0 0 0 0 2; SSR 0 0 1;
  SR 0 0 1e-9 0 0 0 0 0 2; SSR 0 0 1;
  SR 0 0 0 0 0 1e-9 0 0 2; SSR 0 0 1;
  {these define beam boundaries}
  {(useful for determining difference statistics' baoundaries)}
  SR 3e-3 0 0 0 0 0 0 0 2; SSR 0 0 1;
  SR 0 0 3e-3 0 0 0 0 0 2; SSR 0 0 1;
  SR 0 0 0 0 0 1e-4 0 0 2; SSR 0 0 1;
  {spin offset rays}
  LOOP I 1 11;
    DUM := .1*(I - 6);
    SR 1e-9 0 0 0 0 0 0 0 2; SSR DUM 0   SQRT(1-DUM*DUM);
    SR 1e-9 0 0 0 0 0 0 0 2; SSR 0   DUM SQRT(1-DUM*DUM);
  ENDLOOP;

  TRR 1; {enable resuming mode for element-by element tracking}
  LTRPRAY := 0; LTRPSPI := 0; { make sure that TR doesn't output data on its own}
  WTRPRAY 0 0; {WRITE INITIAL STATE TO TRPRAY}
  WTRPSPI 0 0; {TRPSPI}
  LOOP TRN 1 NTRN;
    LOOP EL 1 NEL;
      RMAPS EL MAPARR SPNRARR;
      TR 1 1 -1 -3 1.2 1.2 0 0 -12;
      WTRPRAY TRN EL; WTRPSPI TRN EL;
    ENDLOOP;
  ENDLOOP;
ENDPROCEDURE; {TREL}

PROCEDURE COLWRITE OU VEC;
  VARIABLE N 1; VARIABLE I 1;
  N := LENGTH(VEC);
  LOOP I 1 N; WRITE OU VEC|I; ENDLOOP;
ENDPROCEDURE;


SAVE 'bin/core/utilities';
